"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[51],{1414:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"robot-motion-navigation","title":"Robot Motion & Navigation","description":"Learn how robots plan paths, localize themselves, build maps, and execute stable locomotion, especially for humanoids.","source":"@site/docs/robot-motion-navigation.md","sourceDirName":".","slug":"/robot-motion-navigation","permalink":"/Physical_AI_Robotics_Book/docs/robot-motion-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/robot-motion-navigation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Robot Motion & Navigation","description":"Learn how robots plan paths, localize themselves, build maps, and execute stable locomotion, especially for humanoids.","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Sensing & Perception","permalink":"/Physical_AI_Robotics_Book/docs/sensing-perception"}}');var o=i(4848),a=i(8453);const s={title:"Robot Motion & Navigation",description:"Learn how robots plan paths, localize themselves, build maps, and execute stable locomotion, especially for humanoids.",sidebar_position:5},r="Robot Motion & Navigation",l={},c=[{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Diagram 5.1: Grid-based Path Planning (A* Concept)",id:"diagram-51-grid-based-path-planning-a-concept",level:3},{value:"Motion Control and Trajectory Generation",id:"motion-control-and-trajectory-generation",level:2},{value:"Localization: Knowing Where You Are",id:"localization-knowing-where-you-are",level:2},{value:"Mapping: Building a World Model",id:"mapping-building-a-world-model",level:2},{value:"Simultaneous Localization and Mapping (SLAM)",id:"simultaneous-localization-and-mapping-slam",level:2},{value:"Diagram 5.2: SLAM Overview (Conceptual Loop)",id:"diagram-52-slam-overview-conceptual-loop",level:3},{value:"Gait Generation &amp; Stability Control for Humanoids",id:"gait-generation--stability-control-for-humanoids",level:2},{value:"Learning Outcomes (Chapter 5)",id:"learning-outcomes-chapter-5",level:2},{value:"Practical Exercises",id:"practical-exercises",level:2},{value:"Exercise 5.1: A* Search Path Tracing",id:"exercise-51-a-search-path-tracing",level:3},{value:"Exercise 5.2: Odometry Calculation",id:"exercise-52-odometry-calculation",level:3},{value:"Short Review Questions",id:"short-review-questions",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"robot-motion--navigation",children:"Robot Motion & Navigation"})}),"\n",(0,o.jsx)(n.p,{children:"Once a robot can perceive its environment (Chapter 4), the next critical step is to enable it to move purposefully and navigate effectively. This chapter covers the core algorithms and techniques for robot motion planning, localization, mapping, and the specialized challenges of humanoid locomotion."}),"\n",(0,o.jsx)(n.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Path planning"})," is the process of finding a sequence of movements that takes a robot from a starting configuration to a target configuration while avoiding obstacles and respecting constraints."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Global vs. Local Planning:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Global Planning:"})," Computes a complete path from start to goal based on a known map of the environment. Often computationally intensive and requires an accurate map."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Local Planning:"})," Generates immediate actions to react to unmapped obstacles or dynamic changes in the environment. Usually faster but can get stuck in local minima."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Grid-based Search Algorithms:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dijkstra's Algorithm:"})," Finds the shortest path between nodes in a graph, but can be slow for large grids as it explores all possible directions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.em,{children:[(0,o.jsx)(n.em,{children:"A"})," Search Algorithm:"]}),"* An extension of Dijkstra's that uses a ",(0,o.jsx)(n.strong,{children:"heuristic function"})," to guide the search towards the goal, making it much more efficient. It finds the shortest path while exploring fewer nodes.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Heuristic:"})," An educated guess about the remaining cost to reach the goal (e.g., Euclidean distance or Manhattan distance). The heuristic must be admissible (never overestimates the cost) for A* to guarantee optimality."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Sampling-based Algorithms:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.em,{children:[(0,o.jsx)(n.em,{children:"Rapidly-exploring Random Trees (RRT/RRT"}),"):"]}),"* Build a tree of possible paths by randomly sampling points in the configuration space and extending the tree towards them. Effective for high-dimensional spaces and complex obstacles. RRT* improves optimality."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Probabilistic Roadmaps (PRM):"})," Constructs a roadmap (graph) by randomly sampling points and connecting them if a collision-free path exists between them. Once the roadmap is built, pathfinding becomes a graph search problem."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"diagram-51-grid-based-path-planning-a-concept",children:"Diagram 5.1: Grid-based Path Planning (A* Concept)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"        Start [S] . . . . .\n        . . X X . .\n        . . X G . .\n        . . X . . .\n        . . . . . .\n        X = Obstacle\n        G = Goal\n        Arrows would show the path explored/found.\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Description: A 2D grid map representing an environment with a start point [S], a goal point [G], and obstacles denoted by [X]. The illustration conceptually depicts how a path planning algorithm like A"})," would navigate through the grid, expanding its search and finding an optimal collision-free path from S to G.*"]}),"\n",(0,o.jsx)(n.h2,{id:"motion-control-and-trajectory-generation",children:"Motion Control and Trajectory Generation"}),"\n",(0,o.jsx)(n.p,{children:"After a path is planned, the robot needs to execute it smoothly and precisely."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Trajectory Generation:"})," Converting a static path into a time-parameterized sequence of joint positions, velocities, and accelerations that the robot can follow. This ensures smooth movement and avoids jerky motions that could damage the robot or objects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feedback Control:"})," (Revisited from Chapter 2) Lower-level control loops (like PID) are used at each joint to ensure the actual joint positions and velocities match the commanded trajectory."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"localization-knowing-where-you-are",children:"Localization: Knowing Where You Are"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Localization"})," is the process of determining a robot's position and orientation within a known map."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Odometry:"})," Estimates position by integrating wheel encoder readings or joint angles over time. Simple and fast, but prone to cumulative errors (drift) due to wheel slippage or measurement noise.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Pseudocode for simple 2-wheel differential drive odometry:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pseudocode",children:"// Initial state\nx = 0\ny = 0\ntheta = 0 // Orientation (heading)\n\n// Robot parameters\nwheel_radius = R\nwheel_base = L // Distance between wheels\n\n// In a loop (at time step dt):\nfunction update_odometry(left_encoder_delta, right_encoder_delta, dt):\n    // Convert encoder deltas to wheel distances\n    dist_left = left_encoder_delta * (2 * PI * wheel_radius / encoder_ticks_per_rev)\n    dist_right = right_encoder_delta * (2 * PI * wheel_radius / encoder_ticks_per_rev)\n\n    // Calculate instantaneous center of robot movement\n    delta_dist = (dist_left + dist_right) / 2\n    delta_theta = (dist_right - dist_left) / L\n\n    // Update state\n    x = x + delta_dist * cos(theta + delta_theta / 2)\n    y = y + delta_dist * sin(theta + delta_theta / 2)\n    theta = theta + delta_theta\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Global Positioning System (GPS):"})," Provides absolute position outdoors, but suffers from inaccuracies, requires line-of-sight to satellites, and doesn't work indoors."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Beacon-based Localization:"})," Uses fixed transmitters (beacons) and signal strength or time-of-flight measurements to triangulate the robot's position."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Bayesian Localization:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Markov Localization:"})," Represents the robot's belief about its position as a probability distribution over the map. Updates this belief using sensor observations and motion models."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Monte Carlo Localization (MCL) / Particle Filters:"}),' A popular implementation of Markov Localization that uses a set of weighted "particles" (hypothesized robot poses) to represent the probability distribution. Particles are updated based on motion and sensor models.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"mapping-building-a-world-model",children:"Mapping: Building a World Model"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Mapping"})," is the process of constructing a representation of the environment."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Occupancy Grids:"})," The most common map representation, dividing the environment into a grid of cells, each storing a probability of being occupied by an obstacle."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feature-based Maps:"})," Represent the environment using a collection of distinct landmarks or features."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Topological Maps:"})," Represent the environment as a graph of nodes (places) and edges (paths between places), often used for high-level navigation."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"simultaneous-localization-and-mapping-slam",children:"Simultaneous Localization and Mapping (SLAM)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"SLAM"})," is arguably one of the most fundamental and challenging problems in robotics. It's the chicken-and-egg problem: a robot needs a map to localize itself, but it needs to localize itself to build a map. SLAM algorithms solve both problems simultaneously, often using sensor data (Lidar, cameras, IMUs) to iteratively refine both the robot's pose estimate and the map of its surroundings."]}),"\n",(0,o.jsx)(n.h3,{id:"diagram-52-slam-overview-conceptual-loop",children:"Diagram 5.2: SLAM Overview (Conceptual Loop)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"        +-----------------+     +-----------------+\n        |  Robot Sensors  |----\x3e|   Perception    |\n        | (e.g., Lidar)   |     | (Features, Data)|\n        +-----------------+     +-----------------+\n                 |                         |\n                 |                         V\n                 |    +-----------------+  <---\x3e +------------+\n                 +----\x3e|   Localization  |<-----\x3e|   Mapping  |\n                       | (Where am I?)   |       | (Build Map)|\n                       +-----------------+       +------------+\n                 ^                         |\n                 |                         V\n                 |    +-----------------+\n                 +----|  Motion Control   |\n                      | (Move to goal)  |\n                      +-----------------+\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Description: A conceptual loop illustrating the Simultaneous Localization and Mapping (SLAM) problem, showing the interaction between robot sensors, perception, localization, mapping, and motion control. The robot builds a map while simultaneously figuring out its position within that map."})}),"\n",(0,o.jsx)(n.h2,{id:"gait-generation--stability-control-for-humanoids",children:"Gait Generation & Stability Control for Humanoids"}),"\n",(0,o.jsx)(n.p,{children:"Bipedal locomotion (walking on two legs) is inherently unstable and incredibly complex compared to wheeled or quadrupedal motion."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gait Generation:"})," Designing the sequence of joint motions (foot placements, leg swings, body postures) that produce stable and efficient walking.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Static Gaits:"})," Robot moves slowly enough that its center of mass always remains within its support polygon (area defined by feet on the ground). Simpler but slow and less human-like."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Gaits:"})," Robot's center of mass moves outside its support polygon during walking, relying on continuous feedback and momentum to maintain balance. More efficient and human-like."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Zero Moment Point (ZMP) (Revisited):"})," A fundamental concept for bipedal stability. A stable gait ensures the ZMP always stays within the convex hull of the robot's contact points with the ground (i.e., its feet)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Balancing & Stability Control:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inverse Pendulum Model:"})," A common simplification used to model the dynamics of a bipedal robot during walking, helping to design balance controllers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Center of Mass (CoM) Control:"})," Actively shifting the robot's CoM to maintain balance or initiate steps."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Momentum Control:"})," Using the robot's angular and linear momentum to absorb disturbances and maintain stability during dynamic movements."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Whole-Body Control (WBC):"})," A sophisticated approach that considers all of the robot's joints and end-effectors simultaneously to achieve a desired task (e.g., walking while carrying an object) while maintaining balance and avoiding joint limits."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"learning-outcomes-chapter-5",children:"Learning Outcomes (Chapter 5)"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this chapter, you should be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Describe the difference between global and local path planning."}),"\n",(0,o.jsx)(n.li,{children:"Explain the working principles of A* and RRT algorithms."}),"\n",(0,o.jsx)(n.li,{children:"Compare and contrast odometry, GPS, and Bayesian localization methods."}),"\n",(0,o.jsx)(n.li,{children:"Understand the fundamental challenge and conceptual solution of SLAM."}),"\n",(0,o.jsx)(n.li,{children:"Differentiate between static and dynamic gaits for humanoids."}),"\n",(0,o.jsx)(n.li,{children:"Explain how ZMP and Center of Mass control contribute to bipedal stability."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"practical-exercises",children:"Practical Exercises"}),"\n",(0,o.jsx)(n.h3,{id:"exercise-51-a-search-path-tracing",children:"Exercise 5.1: A* Search Path Tracing"}),"\n",(0,o.jsx)(n.p,{children:"Consider the following 5x5 grid map, where 'S' is the start, 'G' is the goal, and 'X' represents obstacles."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"S . . . .\n. X . X .\n. X . G .\n. . . X .\n. . . . .\n"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Assume the robot can move horizontally and vertically (4-connectivity)."}),"\n",(0,o.jsx)(n.li,{children:"Using Manhattan distance as a heuristic (H), conceptually trace the path an A* algorithm would explore to find the shortest path from S to G."}),"\n",(0,o.jsx)(n.li,{children:"Indicate the shortest path found."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"exercise-52-odometry-calculation",children:"Exercise 5.2: Odometry Calculation"}),"\n",(0,o.jsxs)(n.p,{children:["A differential drive robot has ",(0,o.jsx)(n.code,{children:"wheel_radius = 0.05"})," meters and ",(0,o.jsx)(n.code,{children:"wheel_base = 0.2"})," meters. Its encoders report total ticks. Assume ",(0,o.jsx)(n.code,{children:"encoder_ticks_per_rev = 360"})," (1 degree per tick).\nAt ",(0,o.jsx)(n.code,{children:"t=0"}),", robot is at ",(0,o.jsx)(n.code,{children:"(x=0, y=0, theta=0)"}),".\nBetween ",(0,o.jsx)(n.code,{children:"t=0"})," and ",(0,o.jsx)(n.code,{children:"t=1s"}),": ",(0,o.jsx)(n.code,{children:"left_encoder_delta = 36"})," ticks, ",(0,o.jsx)(n.code,{children:"right_encoder_delta = 72"})," ticks."]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Calculate ",(0,o.jsx)(n.code,{children:"dist_left"})," and ",(0,o.jsx)(n.code,{children:"dist_right"})," for this 1-second interval."]}),"\n",(0,o.jsxs)(n.li,{children:["Use the ",(0,o.jsx)(n.code,{children:"update_odometry"})," pseudocode to calculate the robot's new ",(0,o.jsx)(n.code,{children:"(x, y, theta)"})," at ",(0,o.jsx)(n.code,{children:"t=1s"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"short-review-questions",children:"Short Review Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"What is a major advantage of using a sampling-based path planner (like RRT) over a grid-based planner (like A*) for high-dimensional robotic systems?"}),"\n",(0,o.jsx)(n.li,{children:"Why is a simple odometry system prone to accumulating errors over longer distances?"}),"\n",(0,o.jsx)(n.li,{children:'Explain the "chicken-and-egg" problem that Simultaneous Localization and Mapping (SLAM) aims to solve.'}),"\n",(0,o.jsx)(n.li,{children:'What is the primary difference in how a robot maintains balance during a "static gait" versus a "dynamic gait"?'}),"\n",(0,o.jsx)(n.li,{children:'How does the concept of the "Inverse Pendulum Model" simplify the problem of controlling humanoid robot balance?'}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);